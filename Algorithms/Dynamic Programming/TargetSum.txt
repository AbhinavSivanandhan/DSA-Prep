class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        dp = {}  # (index, total) -> # of ways

        def backtrack(i, total):
            if i == len(nums):
                return 1 if total == target else 0
            if (i, total) in dp:
                return dp[(i, total)]

            dp[(i, total)] = (backtrack(i + 1, total + nums[i]) +
                              backtrack(i + 1, total - nums[i]))
            return dp[(i, total)]

        return backtrack(0, 0)

**Time complexity:Â O(nâˆ—m)**

**Space complexity:Â O(nâˆ—m)**

WhereÂ nÂ is the length of the arrayÂ numsÂ andÂ mÂ is the sum of all the elements in the array.


âœ… **Fantastic question! Letâ€™s build this solution from scratch, starting from brute force â†’ to memoized DP â†’ with recurrence + base case clearly explained.**

---

## ğŸŒŸ **Problem recap**

ğŸ‘‰ Youâ€™re given `nums` â€” pick + or - for each number

ğŸ‘‰ Goal: count how many ways sum = `target`

---

## 1ï¸âƒ£ **Brute force idea**

ğŸ‘‰ For each `num`, we have 2 choices:

- Add it â†’ `+num`
- Subtract it â†’ `num`

ğŸ‘‰ At each index:

- Recurse on next index with updated total.

---

### Brute force code

```python
def backtrack(i, total):
    if i == len(nums):
        return 1 if total == target else 0

    return (backtrack(i + 1, total + nums[i]) +
            backtrack(i + 1, total - nums[i]))

```

âœ… Explore all 2^N possibilities.

---

### Base case

```python
if i == len(nums):
    return 1 if total == target else 0

```

ğŸ‘‰ When weâ€™ve used all numbers:

- If total = target â†’ 1 valid way
- Else â†’ 0

---

### Recurrence relation

ğŸ‘‰ Number of ways from `(i, total)`:

```
ways(i, total) = ways(i+1, total + nums[i]) + ways(i+1, total - nums[i])

```

âœ… Either:

- Use +nums[i]
- Use -nums[i]

---

## 2ï¸âƒ£ **Why brute force is slow**

ğŸ‘‰ **Exponential time: O(2^N)**

ğŸ‘‰ Overlapping subproblems:

- Same index + total pair visited many times

E.g. at index 3, total 5 â†’ you might reach this in multiple ways

---

## 3ï¸âƒ£ **Add memoization (DP)**

ğŸ‘‰ Letâ€™s store:

```
dp[(i, total)] = number of ways to reach target from index i with sum total

```

So we compute each (i, total) only once.

---

### Memoized code

```python
dp = {}

def backtrack(i, total):
    if i == len(nums):
        return 1 if total == target else 0

    if (i, total) in dp:
        return dp[(i, total)]

    dp[(i, total)] = (backtrack(i + 1, total + nums[i]) +
                      backtrack(i + 1, total - nums[i]))

    return dp[(i, total)]

```

âœ… Now itâ€™s O(N * sumRange) where sumRange = possible range of totals.

âœ… No repeated work!

---

## ğŸ“ **Final recurrence + base case**

### Recurrence

```
ways(i, total) = ways(i+1, total + nums[i]) + ways(i+1, total - nums[i])

```

### Base case

```
ways(len(nums), total) =
  1 if total == target
  0 otherwise

```

---

## â± Time + space

âœ… **Time:** O(N * S)

ğŸ‘‰ S = sum of nums * 2 (to cover all possible totals)

âœ… **Space:** O(N * S) for DP

---

## ğŸŒˆ **Intuitive flow**

ğŸ‘‰ Start at index 0, sum = 0

ğŸ‘‰ Try adding +nums[0] â†’ recurse

ğŸ‘‰ Try adding -nums[0] â†’ recurse

ğŸ‘‰ Cache as you go so you donâ€™t repeat work

---

ğŸ’¡ **Summary of evolution**

| Stage | Approach | Time | Notes |
| --- | --- | --- | --- |
| Brute force | Recurse all paths | O(2^N) | Slow, repeats work |
| Memoization | Cache (i, total) | O(N * S) | Efficient, avoids recomputation |

---

If you'd like, I can walk through a small input like `nums = [1,1,1,1,1], target=3` step-by-step! ğŸš€
