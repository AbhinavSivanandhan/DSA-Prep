Not as Hard as regular leetcode hard

Drawing explanation

![image.png](attachment:fa3160c5-9839-47e1-b202-a520b4ab7eab:image.png)

edge case/part, no need to reverse if group has less than k nodes. Eg: 5

**Iteration**

**Time complexity:Â O(n)**

**Space complexity:Â O(1)**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        groupPrev = dummy

        while True:
            kth = self.getKth(groupPrev, k)
            if not kth:
                break
            groupNext = kth.next

            prev, curr = kth.next, groupPrev.next
            while curr != groupNext:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            tmp = groupPrev.next
            groupPrev.next = kth
            groupPrev = tmp
        return dummy.next

    def getKth(self, curr, k):
        while curr and k > 0:
            curr = curr.next
            k -= 1
        return curr
```

letâ€™s break this solution down **super carefully**, because it's actually a "template" that gets reused a lot in advanced linked list problems.

---

# ðŸ§  Problem:

Given a linked list, reverse every **k** nodes.

If there are fewer than `k` nodes at the end, **leave them as-is**.

Example:

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k=3
Output: 3 â†’ 2 â†’ 1 â†’ 4 â†’ 5

```

(First 3 nodes reversed, last 2 not reversed.)

---

# ðŸ› ï¸ Code Walkthrough:

---

## Step 1: Setup dummy node

```python
dummy = ListNode(0, head)
groupPrev = dummy

```

- `dummy` is a fake node before head, helps handle edge cases smoothly.
- `groupPrev` keeps track of the **node before** the current group we're about to reverse.

---

## Step 2: Main While Loop

```python
while True:
    kth = self.getKth(groupPrev, k)
    if not kth:
        break

```

- **Find the kth node** from `groupPrev` (i.e., the last node of the group).
- If there aren't `k` nodes left (`kth == None`), **weâ€™re done**.

---

## Step 3: Save next group's head

```python
groupNext = kth.next

```

- After reversing the current group, we will need to connect the **tail** of this group to the **head of the next group** (`groupNext`).

---

## Step 4: Reverse the group

```python
prev, curr = kth.next, groupPrev.next
while curr != groupNext:
    tmp = curr.next
    curr.next = prev
    prev = curr
    curr = tmp

```

This is **normal linked list reversal**, but **stopping exactly at groupNext**.

Visual:

(Before reverse)

```
groupPrev â†’ 1 â†’ 2 â†’ 3 â†’ groupNext

```

After reversing **[1,2,3]**:

```
groupPrev â†’ 3 â†’ 2 â†’ 1 â†’ groupNext

```

Explanation:

- `curr` walks forward.
- At every step, point `curr.next` backwards to `prev`.
- Move `curr` forward using `tmp`.
- `prev` keeps track of the last reversed node.

---

## Step 5: Reconnect reversed group

```python
tmp = groupPrev.next
groupPrev.next = kth
groupPrev = tmp

```

- After reversing, **`groupPrev.next` should point to `kth`** (new head of the group).
- Move `groupPrev` to the **end of the newly reversed group** (which used to be the start before reversal â€” thatâ€™s why we store `tmp`).
    - Think: "move my anchor to the end of the reversed group."

---

## Step 6: Return result

```python
return dummy.next

```

- `dummy.next` is the real new head of the list after reversals.

---

# ðŸ“¦ What is `getKth()` doing?

```python
def getKth(self, curr, k):
    while curr and k > 0:
        curr = curr.next
        k -= 1
    return curr

```

Simple helper:

- Move forward `k` steps from `curr`.
- If you canâ€™t (because `curr` became `None`), return `None`.
- Otherwise, return the **kth node**.

**Why?**

We need to know where to **stop** and **reverse exactly k nodes**.

---

# ðŸ“ˆ Visual Step-by-Step

Example:

Input list = `1 â†’ 2 â†’ 3 â†’ 4 â†’ 5`, `k = 3`

- **First loop:**
    - `groupPrev = dummy`
    - `getKth(dummy, 3)` â†’ finds node 3
    - Reverse 1 â†’ 2 â†’ 3
    - List becomes: `3 â†’ 2 â†’ 1 â†’ 4 â†’ 5`
    - Move `groupPrev` to 1
- **Second loop:**
    - `groupPrev = 1`
    - `getKth(1, 3)` â†’ fails (only 2 nodes left)
    - **Done**

Result: `3 â†’ 2 â†’ 1 â†’ 4 â†’ 5`

---

# ðŸŽ¯ Key Intuition:

| Step | Why Important |
| --- | --- |
| `dummy` | Handle the head reversal cleanly |
| `getKth()` | Know the boundaries of groups |
| `prev, curr reversal` | Standard linked list reversal |
| Reconnect group | Stitch reversed parts correctly |

---

# âš¡ Memory Trick:

**Think in groups of `k`:**

- Find group
- Reverse group
- Reconnect group
- Move anchor (`groupPrev`) to next

---

# ðŸ§  Quick Final Thought:

This **template** (dummy â†’ find group â†’ reverse â†’ reconnect) will appear again and again in **Linked List segment problems**, like:

- Reverse between positions m and n
- Swap nodes in pairs
- Rotate list

---

Would you like me to also show you a slightly faster **"in-place no extra dummy" version** (but a little trickier)?

(Useful for super clean interviews!) ðŸŽ¯ðŸš€
